<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sure! Pl Commit Census</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Fraunces:opsz,wght@9..144,600&display=swap" />
  <style>
    :root {
      --paper: #f7f1e7;
      --paper-deep: #efe4d4;
      --ink: #1b1b1b;
      --ink-muted: rgba(27,27,27,0.6);
      --accent: #ff7a1a;
      --accent-2: #0d9488;
      --accent-3: #f2c94c;
      --panel: rgba(255,255,255,0.72);
      --border: rgba(27,27,27,0.12);
      --shadow: 0 12px 28px rgba(27,27,27,0.12);
      --radius: 18px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: "Space Grotesk", system-ui, -apple-system, "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 0%, rgba(255,122,26,0.18), transparent 42%),
        radial-gradient(circle at 85% 15%, rgba(13,148,136,0.18), transparent 48%),
        linear-gradient(180deg, var(--paper), var(--paper-deep));
      min-height: 100vh;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image:
        repeating-linear-gradient(45deg, rgba(27,27,27,0.03) 0 1px, transparent 1px 14px),
        repeating-linear-gradient(-45deg, rgba(27,27,27,0.02) 0 1px, transparent 1px 18px);
      pointer-events: none;
      z-index: 0;
    }
    a { color: inherit; }
    .wrap {
      position: relative;
      z-index: 1;
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 20px 40px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .hero {
      display: grid;
      gap: 12px;
      padding: 18px 20px;
      border-radius: 22px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      animation: rise 0.7s ease-out both;
    }
    .hero-top {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    .badge {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.7);
      font-size: 12px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .hero h1 {
      margin: 0;
      font-family: "Fraunces", serif;
      font-size: clamp(28px, 4vw, 42px);
      letter-spacing: -0.02em;
    }
    .hero p {
      margin: 0;
      color: var(--ink-muted);
      max-width: 680px;
    }
    .meta {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--ink-muted);
    }
    .meta strong { color: var(--ink); }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
    }
    .panel {
      padding: 16px 18px;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: var(--panel);
      box-shadow: var(--shadow);
      display: grid;
      gap: 12px;
      animation: rise 0.6s ease-out both;
      animation-delay: var(--delay, 0s);
    }
    .panel h2 {
      margin: 0;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    .panel h3 {
      margin: 0;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--ink-muted);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .stack { display: grid; gap: 10px; }
    .grow { flex: 1 1 auto; min-width: 0; }
    label {
      display: block;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--ink-muted);
      margin-bottom: 4px;
    }
    input[type="text"], input[type="number"], select, textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.7);
      font-family: inherit;
      color: inherit;
      outline: none;
    }
    textarea { min-height: 120px; resize: vertical; }
    button {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.7);
      font-family: inherit;
      cursor: pointer;
    }
    button.primary {
      background: linear-gradient(180deg, var(--accent), #ffb04d);
      color: #1b1b1b;
      border-color: rgba(255,122,26,0.5);
      font-weight: 600;
    }
    button.secondary {
      background: linear-gradient(180deg, rgba(13,148,136,0.2), rgba(13,148,136,0.08));
      border-color: rgba(13,148,136,0.4);
    }
    button.ghost { background: transparent; }
    button:hover { transform: translateY(-1px); }
    .dropzone {
      border: 1px dashed rgba(27,27,27,0.2);
      border-radius: 14px;
      padding: 14px;
      background: rgba(255,255,255,0.5);
      text-align: center;
      font-size: 13px;
      color: var(--ink-muted);
    }
    .dropzone.dragover {
      border-color: var(--accent);
      background: rgba(255,122,26,0.12);
      color: var(--ink);
    }
    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(255,255,255,0.7);
    }
    .status {
      font-size: 12px;
      color: var(--ink-muted);
    }
    .status.error { color: #b42318; }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
    }
    .stat {
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.75);
      display: grid;
      gap: 4px;
    }
    .stat strong {
      font-size: 20px;
      letter-spacing: -0.02em;
    }
    .stat span {
      font-size: 12px;
      color: var(--ink-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .chart {
      display: grid;
      gap: 10px;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .chart-bars {
      height: 240px;
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(4px, 1fr);
      align-items: end;
      gap: 6px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.7);
      overflow: hidden;
    }
    .bar {
      border-radius: 999px 999px 8px 8px;
      border: 1px solid rgba(0,0,0,0.08);
      background: linear-gradient(180deg, var(--accent), #ffb04d);
      height: 0%;
      transition: height 0.8s ease;
      cursor: pointer;
    }
    .bar.selected {
      background: linear-gradient(180deg, var(--accent-2), #23c2a7);
      border-color: rgba(13,148,136,0.4);
    }
    .chart-axis {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--ink-muted);
    }
    .table {
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.75);
      overflow: hidden;
    }
    .split-table {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(27,27,27,0.08);
      text-align: left;
    }
    th {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--ink-muted);
    }
    tbody tr:hover { background: rgba(255,122,26,0.08); }
    .note {
      font-size: 12px;
      color: var(--ink-muted);
    }
    .footer {
      text-align: center;
      font-size: 12px;
      color: var(--ink-muted);
      padding: 10px 0 20px;
    }
    @keyframes rise {
      from { opacity: 0; transform: translateY(14px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      .chart-bars { height: 200px; }
    }
    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="hero">
      <div class="hero-top">
        <div class="badge">Cursor commit census</div>
        <span class="pill" id="statusPill">Awaiting data</span>
      </div>
      <h1>Sure! Pl commit census</h1>
      <p>Estimate public repo creation velocity by clustering commits that include the "Sure! Pl" message. Load a JSON export, slice the last 90 days, and explore who is shipping the most Cursor-born repos.</p>
      <div class="meta">
        <div>Source: <strong id="metaSource">Local file</strong></div>
        <div>Query: <strong id="metaQuery">"Sure! Pl"</strong></div>
        <div>Collected: <strong id="metaCollected">-</strong></div>
      </div>
    </section>

    <div class="grid">
      <section class="panel" style="--delay: 0.1s">
        <h2>Load data</h2>
        <div class="dropzone" id="dropzone">Drop a JSON file here or use the picker below.</div>
        <div class="row">
          <div class="grow">
            <input type="file" id="fileInput" accept="application/json,.json,.ndjson" />
          </div>
          <button class="secondary" id="loadSampleBtn">Use sample</button>
        </div>
        <div class="stack">
          <label for="pasteInput">Or paste JSON</label>
          <textarea id="pasteInput" placeholder="Paste JSON or NDJSON"></textarea>
          <div class="row">
            <button class="primary" id="parseBtn">Parse pasted data</button>
            <button class="ghost" id="clearBtn">Clear</button>
          </div>
        </div>
        <div class="status" id="statusText">No dataset loaded yet.</div>
      </section>

      <section class="panel" style="--delay: 0.2s">
        <h2>Filters</h2>
        <div class="row">
          <div class="grow">
            <label for="metricSelect">Metric</label>
            <select id="metricSelect">
              <option value="repos">Unique repos (proxy for new repos)</option>
              <option value="commits">All matching commits</option>
            </select>
          </div>
          <div class="grow">
            <label for="bucketSelect">Bucket</label>
            <select id="bucketSelect">
              <option value="day">Daily</option>
              <option value="week">Weekly (Mon start)</option>
              <option value="month">Monthly</option>
            </select>
          </div>
          <div class="grow">
            <label for="dateFieldSelect">Date field</label>
            <select id="dateFieldSelect">
              <option value="committer">Committer date</option>
              <option value="author">Author date</option>
            </select>
          </div>
          <div class="grow">
            <label for="lookbackInput">Lookback (days)</label>
            <input type="number" id="lookbackInput" min="1" max="365" value="90" />
          </div>
        </div>
        <div class="row">
          <button class="primary" id="applyBtn">Apply filters</button>
          <button class="ghost" id="fullRangeBtn">Use full range</button>
          <button class="ghost" id="downloadSeriesBtn">Download bucket CSV</button>
          <button class="ghost" id="downloadNormalizedBtn">Download normalized JSON</button>
        </div>
      </section>

      <section class="panel" style="--delay: 0.3s">
        <h2>Snapshot</h2>
        <div class="stats">
          <div class="stat">
            <span>Total commits</span>
            <strong id="statCommits">0</strong>
          </div>
          <div class="stat">
            <span>Unique repos</span>
            <strong id="statRepos">0</strong>
          </div>
          <div class="stat">
            <span>Unique creators</span>
            <strong id="statCreators">0</strong>
          </div>
          <div class="stat">
            <span>Range</span>
            <strong id="statRange">-</strong>
          </div>
        </div>
        <div class="note" id="rangeNote">Load data to see a 90-day view.</div>
      </section>

      <section class="panel" style="--delay: 0.35s">
        <div class="chart-header">
          <h2>Release tempo</h2>
          <span class="pill" id="chartPill">Daily</span>
        </div>
        <div class="chart">
          <div class="chart-bars" id="chartBars"></div>
          <div class="chart-axis">
            <span id="axisStart">-</span>
            <span id="axisEnd">-</span>
          </div>
        </div>
        <div class="note">Click a bar to drill into that bucket.</div>
      </section>

      <section class="panel" style="--delay: 0.4s">
        <div class="chart-header">
          <h2>Top creators</h2>
          <span class="pill" id="creatorPill">Repos</span>
        </div>
        <div class="table">
          <table>
            <thead>
              <tr>
                <th>Creator</th>
                <th>Count</th>
                <th>Sample repo</th>
              </tr>
            </thead>
            <tbody id="creatorTable"></tbody>
          </table>
        </div>
      </section>

      <section class="panel" style="--delay: 0.42s">
        <div class="chart-header">
          <h2>Project clusters</h2>
          <span class="pill" id="clusterPill">By repo</span>
        </div>
        <div class="split-table">
          <div class="table">
            <table>
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Count</th>
                  <th>Sample repo</th>
                </tr>
              </thead>
              <tbody id="categoryTable"></tbody>
            </table>
          </div>
          <div class="table">
            <table>
              <thead>
                <tr>
                  <th>Topic</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody id="topicTable"></tbody>
            </table>
          </div>
        </div>
        <div class="note" id="clusterNote">Load repo metadata to see categories and topics.</div>
      </section>

      <section class="panel" style="--delay: 0.45s">
        <div class="chart-header">
          <h2>Bucket detail</h2>
          <span class="pill" id="bucketPill">None</span>
        </div>
        <div class="table">
          <table>
            <thead>
              <tr>
                <th>Repo</th>
                <th>Category</th>
                <th>Creator</th>
                <th>Date</th>
                <th>Commit</th>
              </tr>
            </thead>
            <tbody id="bucketTable"></tbody>
          </table>
        </div>
        <div class="note" id="bucketNote">Select a bar to see repos in that bucket.</div>
      </section>
    </div>

    <section class="panel" style="--delay: 0.5s">
      <h2>Method and caveats</h2>
      <div class="stack">
        <div class="note">This dataset counts public commits that include the message "Sure! Pl" and treats the earliest commit per repo as the repo start date.</div>
        <div class="note">GitHub search is capped at 1000 results per query. The fetch script splits time windows to reduce missed results.</div>
        <div class="note">Private repositories are not visible, so counts are a public-only proxy. Use the ratios as directional, not definitive.</div>
        <div class="note">Project categories are inferred from repo topics, descriptions, and primary language. They are heuristic, not authoritative.</div>
      </div>
    </section>

    <div class="footer">Static page. No server required. Load data locally and explore.</div>
  </div>

  <script>
    const state = {
      records: [],
      repos: new Map(),
      meta: {},
      options: {
        metric: "repos",
        bucket: "day",
        dateField: "committer",
        lookbackDays: 90
      },
      selection: {
        bucketKey: null
      }
    };

    const el = {
      statusPill: document.getElementById("statusPill"),
      statusText: document.getElementById("statusText"),
      metaSource: document.getElementById("metaSource"),
      metaQuery: document.getElementById("metaQuery"),
      metaCollected: document.getElementById("metaCollected"),
      dropzone: document.getElementById("dropzone"),
      fileInput: document.getElementById("fileInput"),
      pasteInput: document.getElementById("pasteInput"),
      parseBtn: document.getElementById("parseBtn"),
      clearBtn: document.getElementById("clearBtn"),
      loadSampleBtn: document.getElementById("loadSampleBtn"),
      metricSelect: document.getElementById("metricSelect"),
      bucketSelect: document.getElementById("bucketSelect"),
      dateFieldSelect: document.getElementById("dateFieldSelect"),
      lookbackInput: document.getElementById("lookbackInput"),
      applyBtn: document.getElementById("applyBtn"),
      fullRangeBtn: document.getElementById("fullRangeBtn"),
      downloadSeriesBtn: document.getElementById("downloadSeriesBtn"),
      downloadNormalizedBtn: document.getElementById("downloadNormalizedBtn"),
      statCommits: document.getElementById("statCommits"),
      statRepos: document.getElementById("statRepos"),
      statCreators: document.getElementById("statCreators"),
      statRange: document.getElementById("statRange"),
      rangeNote: document.getElementById("rangeNote"),
      chartBars: document.getElementById("chartBars"),
      chartPill: document.getElementById("chartPill"),
      axisStart: document.getElementById("axisStart"),
      axisEnd: document.getElementById("axisEnd"),
      creatorTable: document.getElementById("creatorTable"),
      creatorPill: document.getElementById("creatorPill"),
      clusterPill: document.getElementById("clusterPill"),
      categoryTable: document.getElementById("categoryTable"),
      topicTable: document.getElementById("topicTable"),
      clusterNote: document.getElementById("clusterNote"),
      bucketTable: document.getElementById("bucketTable"),
      bucketPill: document.getElementById("bucketPill"),
      bucketNote: document.getElementById("bucketNote")
    };

    function setStatus(message, kind) {
      el.statusText.textContent = message;
      el.statusText.classList.toggle("error", kind === "error");
      el.statusPill.textContent = kind === "error" ? "Data error" : message.includes("Loaded") ? "Loaded" : "Awaiting data";
    }

    function safeText(value, fallback) {
      const text = String(value || "").trim();
      return text || fallback || "";
    }

    function parseJsonInput(text) {
      const trimmed = String(text || "").trim();
      if (!trimmed) throw new Error("Empty input");
      try {
        return JSON.parse(trimmed);
      } catch (err) {
        const lines = trimmed.split(/\r?\n/).filter(line => line.trim());
        if (!lines.length) throw err;
        return lines.map(line => JSON.parse(line));
      }
    }

    function extractItems(data) {
      if (Array.isArray(data)) return { items: data, meta: {}, repos: null };
      if (data && Array.isArray(data.commits)) {
        return { items: data.commits, meta: data.meta || {}, repos: data.repos || data.repo_map || data.repo || null };
      }
      if (data && Array.isArray(data.items)) {
        return { items: data.items, meta: data.meta || {}, repos: data.repos || data.repo_map || data.repo || null };
      }
      throw new Error("Could not find a commits array");
    }

    function normalizeRepos(rawRepos) {
      const repoMap = new Map();
      if (!rawRepos) return repoMap;
      if (Array.isArray(rawRepos)) {
        rawRepos.forEach(repo => {
          if (!repo) return;
          const fullName = repo.full_name || repo.repo || repo.name || repo.fullName;
          if (!fullName) return;
          repoMap.set(fullName, { ...repo, full_name: fullName });
        });
        return repoMap;
      }
      if (typeof rawRepos === "object") {
        Object.entries(rawRepos).forEach(([key, repo]) => {
          if (!repo) return;
          const fullName = repo.full_name || repo.repo || repo.name || repo.fullName || key;
          repoMap.set(fullName, { ...repo, full_name: fullName });
        });
      }
      return repoMap;
    }

    function normalizeRecord(raw) {
      if (!raw || typeof raw !== "object") return null;
      let repoName = "";
      let repoUrl = "";
      const repoObj = raw.repository || raw.repo || raw.repo_data || null;
      if (typeof raw.repo === "string") repoName = raw.repo;
      else if (typeof raw.repository === "string") repoName = raw.repository;
      else if (repoObj) repoName = repoObj.full_name || repoObj.name || repoObj.repo || "";
      if (!repoName && raw.repo_full_name) repoName = raw.repo_full_name;
      repoName = String(repoName || "").trim();
      if (!repoName) return null;
      if (typeof raw.repo_url === "string") repoUrl = raw.repo_url;
      else if (repoObj && typeof repoObj.html_url === "string") repoUrl = repoObj.html_url;
      if (!repoUrl) repoUrl = "https://github.com/" + repoName;

      const sha = String(raw.sha || raw.oid || raw.commit_sha || raw.id || "").trim();
      let commitUrl = raw.commit_url || raw.html_url || raw.url || "";
      if (!commitUrl && repoName && sha) commitUrl = "https://github.com/" + repoName + "/commit/" + sha;

      const commitObj = raw.commit || {};
      const authorObj = raw.author || {};
      const commitAuthor = commitObj.author || {};
      const commitCommitter = commitObj.committer || {};

      const message = String(raw.message || commitObj.message || raw.commit_message || "").trim();
      const authorLogin = String(raw.author_login || authorObj.login || raw.user || raw.creator || "").trim();
      const authorUrl = String(raw.author_url || authorObj.html_url || (authorLogin ? "https://github.com/" + authorLogin : "")).trim();
      const authorName = String(raw.author_name || commitAuthor.name || authorObj.name || "").trim();
      const authorDate = raw.author_date || commitAuthor.date || raw.authored_date || raw.date || "";
      const committerDate = raw.committer_date || commitCommitter.date || raw.committed_date || raw.date || "";
      if (!authorDate && !committerDate) return null;

      return {
        repo: repoName,
        repoUrl,
        sha,
        commitUrl,
        message,
        authorLogin,
        authorUrl,
        authorName,
        authorDate,
        committerDate
      };
    }

    function normalizeRecords(items) {
      const records = [];
      const seen = new Set();
      for (const raw of items) {
        const record = normalizeRecord(raw);
        if (!record) continue;
        const key = record.repo + ":" + (record.sha || record.commitUrl || record.authorDate || record.committerDate || Math.random());
        if (seen.has(key)) continue;
        seen.add(key);
        records.push(record);
      }
      return records;
    }

    function toDate(value) {
      const d = new Date(value);
      return Number.isNaN(d.getTime()) ? null : d;
    }

    function toDateKeyUTC(d) {
      return d.toISOString().slice(0, 10);
    }

    function toMonthKeyUTC(d) {
      const month = String(d.getUTCMonth() + 1).padStart(2, "0");
      return d.getUTCFullYear() + "-" + month;
    }

    function toWeekKeyUTC(d) {
      const base = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
      const day = base.getUTCDay();
      const offset = (day + 6) % 7;
      base.setUTCDate(base.getUTCDate() - offset);
      return toDateKeyUTC(base);
    }

    function startOfWeekUTC(d) {
      const base = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
      const day = base.getUTCDay();
      const offset = (day + 6) % 7;
      base.setUTCDate(base.getUTCDate() - offset);
      return base;
    }

    function startOfMonthUTC(d) {
      return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), 1));
    }

    function formatDateShort(d) {
      return toDateKeyUTC(d);
    }

    function formatAuthor(record) {
      return record.authorLogin || record.authorName || "unknown";
    }

    const CATEGORY_RULES = [
      { label: "iOS", keywords: ["ios", "iphone", "ipad", "swiftui", "uikit", "cocoapods", "app store"] },
      { label: "macOS", keywords: ["macos", "appkit", "mac app", "menubar", "menu bar", "status bar"] },
      { label: "Android", keywords: ["android", "androidx", "jetpack", "kotlin"] },
      { label: "Web", keywords: ["web", "frontend", "react", "nextjs", "next.js", "vue", "svelte", "astro", "nuxt", "vite", "tailwind", "chakra", "remix", "gatsby"] },
      { label: "Backend / API", keywords: ["api", "backend", "server", "graphql", "rest", "fastapi", "django", "rails", "express", "nestjs", "spring", "laravel", "flask", "grpc", "postgres", "mysql"] },
      { label: "Data / AI", keywords: ["ai", "ml", "llm", "pytorch", "tensorflow", "langchain", "dataset", "data", "analysis", "notebook", "nlp", "vector", "embedding"] },
      { label: "Devtools / CLI", keywords: ["cli", "terminal", "devtools", "tooling", "dotfiles", "plugin", "extension", "vscode", "neovim", "vim", "emacs", "cursor"] },
      { label: "Infra / Ops", keywords: ["docker", "kubernetes", "terraform", "devops", "infra", "ci", "github actions", "ansible", "helm", "cloud"] },
      { label: "Games", keywords: ["game", "unity", "godot", "unreal"] },
      { label: "Docs / Content", keywords: ["docs", "documentation", "blog", "notes", "book"] }
    ];

    const LANGUAGE_HINTS = [
      { label: "iOS", languages: ["swift", "objective-c", "objective-c++"] },
      { label: "Android", languages: ["kotlin"] },
      { label: "Web", languages: ["javascript", "typescript", "html", "css"] },
      { label: "Backend / API", languages: ["go", "rust", "java", "c#", "php", "ruby"] },
      { label: "Data / AI", languages: ["python", "jupyter notebook", "r"] },
      { label: "Devtools / CLI", languages: ["shell", "bash", "zsh", "powershell", "lua"] },
      { label: "Infra / Ops", languages: ["hcl", "dockerfile"] }
    ];

    function buildRepoSignal(meta, record) {
      const parts = [];
      if (record && record.repo) parts.push(record.repo);
      if (meta) {
        if (meta.description) parts.push(meta.description);
        if (meta.homepage) parts.push(meta.homepage);
        if (Array.isArray(meta.topics)) parts.push(meta.topics.join(" "));
        if (meta.full_name) parts.push(meta.full_name);
      }
      return parts.join(" ").toLowerCase();
    }

    function classifyRepo(meta, record) {
      const text = buildRepoSignal(meta, record);
      const language = (meta && meta.language ? meta.language : "").toLowerCase();
      const matches = (keywords) => keywords.some(keyword => text.includes(keyword));
      for (const rule of CATEGORY_RULES) {
        if (matches(rule.keywords)) return rule.label;
      }
      if (language === "swift" || language === "objective-c" || language === "objective-c++") {
        return "Apple (Swift)";
      }
      for (const hint of LANGUAGE_HINTS) {
        if (hint.languages.includes(language)) return hint.label;
      }
      return "Unknown";
    }

    function buildTimeline(start, end, bucket) {
      const buckets = [];
      let cursor = new Date(start.getTime());
      if (bucket === "week") cursor = startOfWeekUTC(cursor);
      if (bucket === "month") cursor = startOfMonthUTC(cursor);

      while (cursor <= end) {
        const key = bucket === "day" ? toDateKeyUTC(cursor) : bucket === "week" ? toWeekKeyUTC(cursor) : toMonthKeyUTC(cursor);
        const label = bucket === "week" ? "Week of " + key : key;
        buckets.push({ key, label, date: new Date(cursor.getTime()) });
        if (bucket === "day") cursor.setUTCDate(cursor.getUTCDate() + 1);
        else if (bucket === "week") cursor.setUTCDate(cursor.getUTCDate() + 7);
        else cursor = new Date(Date.UTC(cursor.getUTCFullYear(), cursor.getUTCMonth() + 1, 1));
      }
      return buckets;
    }

    function animateNumber(el, value) {
      const start = Number(el.dataset.value || "0");
      const end = Number(value || 0);
      const duration = 600;
      const startTime = performance.now();
      function tick(now) {
        const t = Math.min(1, (now - startTime) / duration);
        const cur = Math.round(start + (end - start) * t);
        el.textContent = cur.toLocaleString("en-US");
        if (t < 1) requestAnimationFrame(tick);
      }
      el.dataset.value = String(end);
      requestAnimationFrame(tick);
    }

    function computeView() {
      const dateField = state.options.dateField === "author" ? "authorDate" : "committerDate";
      const records = state.records
        .map(record => {
          const dateValue = record[dateField] || record.authorDate || record.committerDate;
          const dateObj = toDate(dateValue);
          if (!dateObj) return null;
          const repoMeta = state.repos instanceof Map ? state.repos.get(record.repo) : null;
          return { ...record, dateObj, repoMeta };
        })
        .filter(Boolean);

      if (!records.length) {
        renderEmpty();
        return;
      }

      let minDate = records[0].dateObj;
      let maxDate = records[0].dateObj;
      for (const record of records) {
        if (record.dateObj < minDate) minDate = record.dateObj;
        if (record.dateObj > maxDate) maxDate = record.dateObj;
      }

      const lookbackDays = Math.max(1, Number(state.options.lookbackDays || 90));
      const startDate = new Date(maxDate.getTime());
      startDate.setUTCDate(startDate.getUTCDate() - (lookbackDays - 1));
      const rangeStart = startDate > minDate ? startDate : minDate;

      const filtered = records.filter(record => record.dateObj >= rangeStart && record.dateObj <= maxDate);

      const repoMap = new Map();
      for (const record of filtered) {
        const key = record.repo;
        const existing = repoMap.get(key);
        if (!existing || record.dateObj < existing.dateObj) repoMap.set(key, record);
      }
      const repoRecords = Array.from(repoMap.values());
      const metricRecords = state.options.metric === "repos" ? repoRecords : filtered;

      const countMap = new Map();
      for (const record of metricRecords) {
        const key = state.options.bucket === "day"
          ? toDateKeyUTC(record.dateObj)
          : state.options.bucket === "week"
            ? toWeekKeyUTC(record.dateObj)
            : toMonthKeyUTC(record.dateObj);
        countMap.set(key, (countMap.get(key) || 0) + 1);
      }

      const buckets = buildTimeline(rangeStart, maxDate, state.options.bucket);
      const series = buckets.map(bucket => ({
        key: bucket.key,
        label: bucket.label,
        value: countMap.get(bucket.key) || 0
      }));

      const creatorMap = new Map();
      for (const record of metricRecords) {
        const name = formatAuthor(record);
        const current = creatorMap.get(name) || { count: 0, sample: record };
        creatorMap.set(name, { count: current.count + 1, sample: current.sample });
      }
      const creators = Array.from(creatorMap.entries())
        .map(([name, data]) => ({ name, count: data.count, sample: data.sample }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 12);

      const uniqueCreators = new Set(filtered.map(record => formatAuthor(record))).size;

      const categoryMap = new Map();
      const topicMap = new Map();
      let hasRepoMeta = false;
      for (const record of repoRecords) {
        const meta = record.repoMeta;
        if (meta) hasRepoMeta = true;
        const category = classifyRepo(meta, record);
        const current = categoryMap.get(category) || { count: 0, sample: record };
        categoryMap.set(category, { count: current.count + 1, sample: current.sample || record });
        if (meta && Array.isArray(meta.topics)) {
          meta.topics.forEach(topic => {
            const key = String(topic || "").toLowerCase().trim();
            if (!key) return;
            topicMap.set(key, (topicMap.get(key) || 0) + 1);
          });
        }
      }
      const categories = Array.from(categoryMap.entries())
        .map(([name, data]) => ({ name, count: data.count, sample: data.sample }))
        .sort((a, b) => b.count - a.count);

      const topics = Array.from(topicMap.entries())
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 12);

      return {
        records: filtered,
        metricRecords,
        series,
        creators,
        categories,
        topics,
        hasRepoMeta,
        minDate,
        maxDate,
        rangeStart,
        uniqueRepos: repoRecords.length,
        uniqueCreators,
        totalCommits: filtered.length
      };
    }

    function renderEmpty() {
      el.chartBars.innerHTML = "";
      el.creatorTable.innerHTML = "";
      el.categoryTable.innerHTML = "";
      el.topicTable.innerHTML = "";
      el.bucketTable.innerHTML = "";
      animateNumber(el.statCommits, 0);
      animateNumber(el.statRepos, 0);
      animateNumber(el.statCreators, 0);
      el.statRange.textContent = "-";
      el.axisStart.textContent = "-";
      el.axisEnd.textContent = "-";
      el.rangeNote.textContent = "Load data to see a 90-day view.";
      el.clusterNote.textContent = "Load repo metadata to see categories and topics.";
      el.bucketNote.textContent = "Select a bar to see repos in that bucket.";
      el.bucketPill.textContent = "None";
    }

    function renderView() {
      const view = computeView();
      if (!view) return;
      animateNumber(el.statCommits, view.totalCommits);
      animateNumber(el.statRepos, view.uniqueRepos);
      animateNumber(el.statCreators, view.uniqueCreators);
      el.statRange.textContent = formatDateShort(view.rangeStart) + " to " + formatDateShort(view.maxDate);
      el.rangeNote.textContent = "Showing " + view.metricRecords.length.toLocaleString("en-US") + " " + (state.options.metric === "repos" ? "repos" : "commits") + " in range.";
      el.chartPill.textContent = state.options.bucket === "day" ? "Daily" : state.options.bucket === "week" ? "Weekly" : "Monthly";
      el.creatorPill.textContent = state.options.metric === "repos" ? "Repos" : "Commits";
      el.clusterPill.textContent = "By repo";
      el.axisStart.textContent = view.series.length ? view.series[0].label : "-";
      el.axisEnd.textContent = view.series.length ? view.series[view.series.length - 1].label : "-";

      const defaultBucket = state.selection.bucketKey || (view.series.length ? view.series[view.series.length - 1].key : null);
      state.selection.bucketKey = defaultBucket;
      renderChart(view.series);
      renderCreators(view.creators);
      renderClusters(view.categories, view.hasRepoMeta);
      renderTopics(view.topics, view.hasRepoMeta);
      renderBucketDetail(view, defaultBucket);
    }

    function renderChart(series) {
      el.chartBars.innerHTML = "";
      const maxValue = Math.max(1, ...series.map(point => point.value));
      series.forEach((point, index) => {
        const bar = document.createElement("button");
        bar.className = "bar" + (point.key === state.selection.bucketKey ? " selected" : "");
        bar.style.height = "0%";
        bar.style.transitionDelay = (index * 12) + "ms";
        bar.title = point.label + ": " + point.value;
        bar.addEventListener("click", () => {
          state.selection.bucketKey = point.key;
          renderView();
        });
        el.chartBars.appendChild(bar);
        requestAnimationFrame(() => {
          bar.style.height = maxValue ? (point.value / maxValue) * 100 + "%" : "0%";
        });
      });
    }

    function renderCreators(creators) {
      el.creatorTable.innerHTML = "";
      creators.forEach(item => {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const countCell = document.createElement("td");
        const sampleCell = document.createElement("td");

        nameCell.textContent = item.name;
        countCell.textContent = item.count.toLocaleString("en-US");
        if (item.sample && item.sample.repo) {
          const link = document.createElement("a");
          link.href = item.sample.repoUrl || "https://github.com/" + item.sample.repo;
          link.textContent = item.sample.repo;
          link.target = "_blank";
          link.rel = "noopener";
          sampleCell.appendChild(link);
        } else {
          sampleCell.textContent = "-";
        }
        row.appendChild(nameCell);
        row.appendChild(countCell);
        row.appendChild(sampleCell);
        el.creatorTable.appendChild(row);
      });
    }

    function renderClusters(categories, hasRepoMeta) {
      el.categoryTable.innerHTML = "";
      if (!hasRepoMeta) {
        el.clusterNote.textContent = "Repo metadata missing. Run fetch_commit_search.py --enrich-repos to cluster.";
      } else {
        el.clusterNote.textContent = "Categories inferred from topics, descriptions, and primary language.";
      }
      if (!categories || !categories.length) {
        return;
      }
      categories.slice(0, 12).forEach(item => {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const countCell = document.createElement("td");
        const sampleCell = document.createElement("td");
        nameCell.textContent = item.name;
        countCell.textContent = item.count.toLocaleString("en-US");
        if (item.sample && item.sample.repo) {
          const link = document.createElement("a");
          const meta = item.sample.repoMeta || {};
          link.href = meta.html_url || item.sample.repoUrl || "https://github.com/" + item.sample.repo;
          link.textContent = item.sample.repo;
          link.target = "_blank";
          link.rel = "noopener";
          sampleCell.appendChild(link);
        } else {
          sampleCell.textContent = "-";
        }
        row.appendChild(nameCell);
        row.appendChild(countCell);
        row.appendChild(sampleCell);
        el.categoryTable.appendChild(row);
      });
    }

    function renderTopics(topics, hasRepoMeta) {
      el.topicTable.innerHTML = "";
      if (!hasRepoMeta || !topics || !topics.length) {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const countCell = document.createElement("td");
        nameCell.textContent = hasRepoMeta ? "No topics found" : "Topics unavailable";
        countCell.textContent = "-";
        row.appendChild(nameCell);
        row.appendChild(countCell);
        el.topicTable.appendChild(row);
        return;
      }
      topics.forEach(item => {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const countCell = document.createElement("td");
        nameCell.textContent = item.name;
        countCell.textContent = item.count.toLocaleString("en-US");
        row.appendChild(nameCell);
        row.appendChild(countCell);
        el.topicTable.appendChild(row);
      });
    }

    function renderBucketDetail(view, bucketKey) {
      if (!bucketKey) {
        el.bucketTable.innerHTML = "";
        el.bucketNote.textContent = "Select a bar to see repos in that bucket.";
        el.bucketPill.textContent = "None";
        return;
      }
      state.selection.bucketKey = bucketKey;
      el.bucketPill.textContent = bucketKey;
      const bucketRecords = view.metricRecords.filter(record => {
        const key = state.options.bucket === "day"
          ? toDateKeyUTC(record.dateObj)
          : state.options.bucket === "week"
            ? toWeekKeyUTC(record.dateObj)
            : toMonthKeyUTC(record.dateObj);
        return key === bucketKey;
      });

      const limit = 150;
      el.bucketTable.innerHTML = "";
      bucketRecords.slice(0, limit).forEach(record => {
        const row = document.createElement("tr");
        const repoCell = document.createElement("td");
        const categoryCell = document.createElement("td");
        const creatorCell = document.createElement("td");
        const dateCell = document.createElement("td");
        const commitCell = document.createElement("td");

        const repoLink = document.createElement("a");
        repoLink.href = record.repoUrl || "https://github.com/" + record.repo;
        repoLink.textContent = record.repo;
        repoLink.target = "_blank";
        repoLink.rel = "noopener";
        repoCell.appendChild(repoLink);

        categoryCell.textContent = classifyRepo(record.repoMeta, record);
        creatorCell.textContent = formatAuthor(record);
        dateCell.textContent = formatDateShort(record.dateObj);

        if (record.commitUrl) {
          const commitLink = document.createElement("a");
          commitLink.href = record.commitUrl;
          commitLink.textContent = record.sha ? record.sha.slice(0, 7) : "view";
          commitLink.target = "_blank";
          commitLink.rel = "noopener";
          commitCell.appendChild(commitLink);
        } else {
          commitCell.textContent = "-";
        }

        row.appendChild(repoCell);
        row.appendChild(categoryCell);
        row.appendChild(creatorCell);
        row.appendChild(dateCell);
        row.appendChild(commitCell);
        el.bucketTable.appendChild(row);
      });

      const note = bucketRecords.length > limit
        ? "Showing " + limit + " of " + bucketRecords.length + " records in this bucket."
        : bucketRecords.length + " records in this bucket.";
      el.bucketNote.textContent = note;
    }

    function applyFilters() {
      state.options.metric = el.metricSelect.value;
      state.options.bucket = el.bucketSelect.value;
      state.options.dateField = el.dateFieldSelect.value;
      state.options.lookbackDays = Number(el.lookbackInput.value || 90);
      renderView();
    }

    function downloadFile(filename, content, type) {
      const blob = new Blob([content], { type: type || "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 500);
    }

    function downloadSeries() {
      const view = computeView();
      if (!view) return;
      const rows = ["bucket,count"].concat(view.series.map(point => point.key + "," + point.value));
      downloadFile("surepl-series.csv", rows.join("\n"), "text/csv");
    }

    function downloadNormalized() {
      if (!state.records.length) return;
      const payload = {
        meta: state.meta,
        commits: state.records
      };
      if (state.repos instanceof Map && state.repos.size) {
        payload.repos = Array.from(state.repos.values());
      }
      downloadFile("surepl-normalized.json", JSON.stringify(payload, null, 2), "application/json");
    }

    function updateMeta(meta) {
      el.metaSource.textContent = safeText(meta.source, "Local file");
      el.metaQuery.textContent = safeText(meta.query, "\"Sure! Pl\"");
      el.metaCollected.textContent = safeText(meta.collected_at, "-");
    }

    function loadDataObject(data) {
      try {
        const { items, meta, repos } = extractItems(data);
        const records = normalizeRecords(items);
        if (!records.length) throw new Error("No valid commit records found");
        const repoMap = normalizeRepos(repos);
        state.records = records;
        state.repos = repoMap;
        state.meta = meta || {};
        state.selection.bucketKey = null;
        updateMeta(state.meta);
        const repoCount = repoMap.size;
        const extra = repoCount ? " + " + repoCount.toLocaleString("en-US") + " repos" : "";
        setStatus("Loaded " + records.length.toLocaleString("en-US") + " records" + extra, "ok");
        renderView();
      } catch (err) {
        setStatus(err.message, "error");
        renderEmpty();
      }
    }

    function loadFromText(text) {
      try {
        const data = parseJsonInput(text);
        loadDataObject(data);
      } catch (err) {
        setStatus("Parse error: " + err.message, "error");
        renderEmpty();
      }
    }

    function buildSampleData() {
      const now = new Date();
      const authors = ["cursor-cat", "prompt-pilot", "ghost-shipper", "patch-pioneer", "seedling-lab"];
      const repos = [
        "cursor-labs/alpha",
        "cursor-labs/beta",
        "cursor-labs/gamma",
        "cursor-labs/delta",
        "cursor-labs/epsilon",
        "cursor-labs/zeta",
        "cursor-labs/eta",
        "cursor-labs/theta",
        "cursor-labs/iota",
        "cursor-labs/kappa"
      ];
      const sampleLanguages = ["Swift", "TypeScript", "Python", "Kotlin", "Go", "Rust"];
      const sampleTopics = [
        ["ios", "swiftui"],
        ["web", "react"],
        ["data", "ml"],
        ["android", "kotlin"],
        ["api", "go"],
        ["cli", "tooling"]
      ];
      const commits = [];
      for (let i = 0; i < 24; i += 1) {
        const date = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
        date.setUTCDate(date.getUTCDate() - i * 3);
        const repo = repos[i % repos.length];
        const author = authors[i % authors.length];
        commits.push({
          repo,
          repo_url: "https://github.com/" + repo,
          sha: "sample" + i,
          commit_url: "https://github.com/" + repo + "/commit/sample" + i,
          message: "Sure! Pl",
          author_login: author,
          author_url: "https://github.com/" + author,
          author_date: date.toISOString(),
          committer_date: date.toISOString()
        });
      }
      commits.push({
        repo: "cursor-labs/alpha",
        repo_url: "https://github.com/cursor-labs/alpha",
        sha: "sample-dup",
        commit_url: "https://github.com/cursor-labs/alpha/commit/sample-dup",
        message: "Sure! Pl",
        author_login: "cursor-cat",
        author_url: "https://github.com/cursor-cat",
        author_date: new Date(now.getTime() - 2 * 86400000).toISOString(),
        committer_date: new Date(now.getTime() - 2 * 86400000).toISOString()
      });
      const repoMeta = repos.map((fullName, index) => {
        const language = sampleLanguages[index % sampleLanguages.length];
        const topics = sampleTopics[index % sampleTopics.length];
        return {
          full_name: fullName,
          html_url: "https://github.com/" + fullName,
          description: "Sample project " + fullName.split("/")[1],
          language,
          topics
        };
      });
      return {
        meta: {
          source: "Sample data",
          query: "\"Sure! Pl\"",
          collected_at: new Date().toISOString()
        },
        commits,
        repos: repoMeta
      };
    }

    el.metricSelect.addEventListener("change", applyFilters);
    el.bucketSelect.addEventListener("change", applyFilters);
    el.dateFieldSelect.addEventListener("change", applyFilters);
    el.applyBtn.addEventListener("click", applyFilters);
    el.fullRangeBtn.addEventListener("click", () => {
      if (!state.records.length) return;
      const dates = state.records.map(record => toDate(record.committerDate || record.authorDate)).filter(Boolean);
      if (!dates.length) return;
      let minDate = dates[0];
      let maxDate = dates[0];
      for (const date of dates) {
        if (date < minDate) minDate = date;
        if (date > maxDate) maxDate = date;
      }
      const spanDays = Math.ceil((maxDate.getTime() - minDate.getTime()) / 86400000) + 1;
      el.lookbackInput.value = String(spanDays || 1);
      applyFilters();
    });
    el.downloadSeriesBtn.addEventListener("click", downloadSeries);
    el.downloadNormalizedBtn.addEventListener("click", downloadNormalized);

    el.parseBtn.addEventListener("click", () => loadFromText(el.pasteInput.value));
    el.clearBtn.addEventListener("click", () => {
      el.pasteInput.value = "";
      el.fileInput.value = "";
      state.records = [];
      state.repos = new Map();
      state.meta = {};
      setStatus("No dataset loaded yet.", "ok");
      updateMeta({});
      renderEmpty();
    });
    el.loadSampleBtn.addEventListener("click", () => loadDataObject(buildSampleData()));

    el.fileInput.addEventListener("change", async (event) => {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const text = await file.text();
      loadFromText(text);
    });

    ["dragenter", "dragover"].forEach(eventName => {
      el.dropzone.addEventListener(eventName, (event) => {
        event.preventDefault();
        el.dropzone.classList.add("dragover");
      });
    });
    ["dragleave", "drop"].forEach(eventName => {
      el.dropzone.addEventListener(eventName, (event) => {
        event.preventDefault();
        el.dropzone.classList.remove("dragover");
      });
    });
    el.dropzone.addEventListener("drop", async (event) => {
      const file = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0];
      if (!file) return;
      const text = await file.text();
      loadFromText(text);
    });

    renderEmpty();
  </script>
</body>
</html>
